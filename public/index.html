<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Twitterもどき</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>

<div class="container">
    <header>
        <h2>Twitterもどき</h2>
        <a href="/logout.php" style="text-decoration: none;">
            <button class="logout-btn">ログアウト</button>
        </a>
    </header>

    <div class="tabs">
        <div class="tab active" onclick="switchTab('follow')" id="tab-follow">フォロー中</div>
        <div class="tab" onclick="switchTab('all')" id="tab-all">すべての投稿</div>
    </div>
    
    <div class="post-area">
        <div class="post-form">
            <textarea id="post_body" placeholder="いまどうしてる？"></textarea>
            <div class="form-actions">
                <div style="display:flex; align-items:center;">
                    <label for="image_input" class="file-upload-label">
                        画像を選択
                    </label>
                    <input type="file" id="image_input" accept="image/*" onchange="updateFileName()">
                    <span id="file-name-display"></span>
                </div>

                <button class="submit-btn" onclick="submitPost()">ツイートする</button>
            </div>
        </div>
    </div>

    <div id="timeline"></div>
    <div id="loading">読み込み中...</div>
    <div id="no-more">すべての投稿を表示しました</div>
</div>

    <script>
        let currentMode = 'follow';
        let currentOffset = 0;
        let isLoading = false;
        let hasMore = true;
        const LIMIT = 5;

        window.onload = () => loadTimeline(false);

        window.onscroll = () => {
            if (!hasMore) return;
            if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100) {
                if (!isLoading) {
                    loadTimeline(true);
                }
            }
        };

        // ファイル名を表示する関数
        function updateFileName() {
            const input = document.getElementById('image_input');
            const display = document.getElementById('file-name-display');
            if (input.files && input.files.length > 0) {
                display.innerText = input.files[0].name;
            } else {
                display.innerText = "";
            }
        }

        function switchTab(mode) {
            currentMode = mode;
            document.getElementById('tab-follow').classList.remove('active');
            document.getElementById('tab-all').classList.remove('active');
            document.getElementById('tab-' + mode).classList.add('active');
            loadTimeline(false);
        }

        async function loadTimeline(isAppend) {
            if (isLoading) return;
            if (isAppend && !hasMore) return;

            isLoading = true;
            document.getElementById('loading').style.display = 'block';
            document.getElementById('no-more').style.display = 'none';

            if (!isAppend) {
                currentOffset = 0;
                hasMore = true;
                document.getElementById('timeline').innerHTML = '';
            }

            const baseUrl = (currentMode === 'follow') ? '/timeline_json.php' : '/timeline_all_json.php';
            const url = `${baseUrl}?limit=${LIMIT}&offset=${currentOffset}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Network error');
                const data = await response.json();

                if (data.entries.length < LIMIT) {
                    hasMore = false;
                }

                const timelineDiv = document.getElementById('timeline');

                if (data.entries.length === 0) {
                    if (!isAppend) {
                        timelineDiv.innerHTML = '<div style="padding:40px 20px; text-align:center; color:#536471;">まだ投稿がありません。<br>「おすすめ」タブから投稿を探してみましょう。</div>';
                        hasMore = false;
                    }
                } else {
                    data.entries.forEach(entry => {
                        const div = document.createElement('div');
                        div.className = 'entry';
                        
                        let imageHtml = '';
                        if (entry.image_file_url) {
                            imageHtml = `<img src="${entry.image_file_url}" class="entry-image" loading="lazy">`;
                        }

                        let actionButton = '';
                        if (entry.is_me) {
                            actionButton = '';
                        } else if (entry.is_following == 1) {
                            actionButton = `<span class="followed-badge">フォロー中</span>`;
                        } else {
                            actionButton = `<button class="follow-btn" onclick="followUser(${entry.user_id})">フォロー</button>`;
                        }

                        div.innerHTML = `
                            <div class="user-icon-placeholder"></div>
                            <div class="entry-content">
                                <div class="entry-header">
                                    <span class="user-name">${entry.user_name}</span>
                                    <div style="display:flex; align-items:center;">
                                        <span class="timestamp">${entry.created_at}</span>
                                        ${actionButton}
                                    </div>
                                </div>
                                <div class="entry-body">${entry.body}</div>
                                ${imageHtml}
                            </div>
                        `;
                        timelineDiv.appendChild(div);
                    });

                    currentOffset += data.entries.length;

                    if (hasMore && document.body.offsetHeight < window.innerHeight) {
                        isLoading = false;
                        await loadTimeline(true);
                        return;
                    }
                }

                if (!hasMore && currentOffset > 0) {
                    document.getElementById('no-more').style.display = 'block';
                }

            } catch (e) {
                console.error(e);
            } finally {
                isLoading = false;
                document.getElementById('loading').style.display = 'none';
            }
        }

        async function followUser(targetUserId) {
            const formData = new URLSearchParams();
            formData.append('target_user_id', targetUserId);
            await fetch('/follow.php', { method: 'POST', body: formData });
            loadTimeline(false);
        }

        async function submitPost() {
            const body = document.getElementById('post_body').value;
            const file = document.getElementById('image_input').files[0];
            
            if (!body && !file) return;

            const btn = document.querySelector('.submit-btn');
            btn.disabled = true;
            btn.innerText = '送信中...';

            let base64Image = null;
            if (file) {
                base64Image = await resizeImage(file, 800);
            }

            const formData = new URLSearchParams();
            formData.append('body', body);
            if (base64Image) formData.append('image_base64', base64Image);

            await fetch('/post.php', { method: 'POST', body: formData });

            document.getElementById('post_body').value = '';
            document.getElementById('image_input').value = '';
            document.getElementById('file-name-display').innerText = ''; // ファイル名表示もリセット
            
            btn.disabled = false;
            btn.innerText = 'ツイートする';
            loadTimeline(false);
        }

        function resizeImage(file, maxWidth) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        if (width > maxWidth) {
                            height = height * (maxWidth / width);
                            width = maxWidth;
                        }
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', 0.8));
                    };
                };
            });
        }
    </script>
</body>
</html>
